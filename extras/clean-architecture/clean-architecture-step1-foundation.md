# クリーンアーキテクチャ - STEP 1: 理論基盤

## 概要

このステップでは、クリーンアーキテクチャの基本的な考え方と概念を学びます。

- **このステップの学習時間**：約1.5～2時間
- **このステップの位置づけ**：すべてのステップの基礎となる理論部分
- **前提知識**：開発経験3年以上、デザインパターンの基本知識
- **このステップの学習成果**：
  - クリーンアーキテクチャの本質を理解する
  - 4つの層構造を把握する
  - 従来のアーキテクチャとの違いを認識する
  - SOLID原則との関連を理解する

---

## 目次

1. [基礎知識](#基礎知識)
   - クリーンアーキテクチャとは何か
   - 提唱者と背景
   - アーキテクチャの重要性
   - SOLID 原則との関連性

2. [コア概念と層構造](#コア概念と層構造)
   - 4 つの層の詳細解説
   - 依存関係の方向性と依存性逆転
   - 層間通信メカニズム
   - ビジネスロジックの中心化

3. [参考リソース](#参考リソース)

---

## 基礎知識

### メイン学習コンテンツ

#### 1. クリーンアーキテクチャとは何か

**クリーンアーキテクチャ**は、ソフトウェアシステムの構成方法を定義する設計思想です。一言で表すと「ビジネスロジックをフレームワークやデータベースなどの詳細から独立させる」というもの。

クリーンアーキテクチャが目指すの次の3つのゴールです：

1. **フレームワーク非依存**
   - 特定のフレームワーク（Spring、Django、 ASP.NET など）に依存しない
   - 別のフレームワークに切り替える際の労力を最小化

2. **テスト容易性**
   - ビジネスロジックをフレームワークやデータベースから切り離す
   - ユニットテストを高速かつ独立して実行可能にする

3. **保守性と拡張性**
   - コードの意図が明確で、新機能追加が容易
   - チーム全体が同じ構造を理解できる

> **重要な考え方**：アーキテクチャの真の目的は「開発初期の速度」ではなく「長期的な保守と変更の容易さ」です。設計に時間をかけることで、開発後期での修正コストを削減します。

**具体例**：ECサイトの注文機能を考えてください。
- クリーンアーキテクチャなし：注文ロジックがデータベース呼び出しやAPIクライアント処理と混在。フレームワーク変更時に全面書き直しが必要。
- クリーンアーキテクチャあり：注文ロジックが純粋な関数として独立。テストは簡単で、フレームワークの変更は外側の層のみ。

#### 2. 提唱者と背景

クリーンアーキテクチャは、**Robert C. Martin（Uncle Bob）** が2012年に提唱しました。

**Robert C. Martin について**：
- 著名なソフトウェアエンジニアで、SOLID 原則の提唱者
- 40年以上のソフトウェア開発経験
- 『Clean Code』『Clean Architecture』など多数の著作

**なぜ生まれたのか**：
多くのプロジェクトで以下の問題が観察されていました：

- フレームワークに深く依存したコードベース
- テストが困難で、変更に弱い構造
- 新機能追加に際して既存コードの修正が多発
- チーム内での設計理解のばらつき

これらの問題を体系的に解決するため、クリーンアーキテクチャという設計哲学が提唱されました。

#### 3. アーキテクチャの重要性

アーキテクチャは「建物」に例えられることが多いです：
- 悪いアーキテクチャ = 基礎の弱い建物 → 拡張時に崩壊のリスク
- 良いアーキテクチャ = 基礎が堅実な建物 → 安全に上階を追加可能

**アーキテクチャが重要な理由**：

| 視点 | 説明 |
|-----|------|
| **開発速度** | 初期は遅いが、後期になるほど改善（通常のコードベースは逆） |
| **バグ率** | 構造が明確なため、バグが減少し、修正が迅速 |
| **チーム間の協力** | 全員が同じ構造を理解しているため、コミュニケーションが効率化 |
| **技術的負債** | 計画的な設計により、技術的負債の蓄積が抑制される |

#### 4. SOLID 原則との関連性

SOLID 原則は、クリーンアーキテクチャの理論的基礎です。クリーンアーキテクチャは SOLID 原則を実装するための実践的な方法論と言えます。

**SOLID 原則の概要**：

| 原則 | 説明 | クリーンアーキテクチャでの役割 |
|-----|-----|---------------------------|
| **S**ingle Responsibility（単一責任） | 1つのクラスは1つの責任のみを持つ | 各層、各クラスが明確な責任を持つ |
| **O**pen/Closed（開放閉鎖） | 拡張に対しては開かれ、修正に対しては閉じられている | 新機能は追加で対応、既存コード修正はなし |
| **L**iskov Substitution（リス코フの置換） | 派生型は基本型に置き換え可能 | インターフェースの適切な設計で実現 |
| **I**nterface Segregation（インターフェース分離） | 特定のインターフェースより多くの具体的なインターフェース | 層間の通信を最小限の必要な操作に限定 |
| **D**ependency Inversion（依存性逆転） | 高レベルモジュールが低レベルに依存しない | クリーンアーキテクチャの核となる原則 |

**SOLID 原則の前提知識がない場合**：
このステップではクリーンアーキテクチャの観点から説明していますが、より詳しく学びたい場合は『Clean Code』などを参照してください。

#### 5. 従来のアーキテクチャとの違い

従来の多層アーキテクチャ（3段階構成）との比較：

```
【従来の多層アーキテクチャ】
┌─────────────────────┐
│   プレゼンテーション層  │
├─────────────────────┤
│    ビジネスロジック層   │
├─────────────────────┤
│   データアクセス層      │
├─────────────────────┤
│    データベース等       │
└─────────────────────┘

【クリーンアーキテクチャ】
        Frameworks & Drivers
                ↑
        Interface Adapters
                ↑
        Application Business Rules
                ↑
        Enterprise Business Rules
```

**主な違い**：

| 項目 | 従来方式 | クリーンアーキテクチャ |
|-----|---------|-------------------|
| **依存関係の向き** | 上から下へ（上位が下位に依存） | 内側へ（外側が内側に依存） |
| **テスト** | UIやDBなしでのテストが困難 | ビジネスロジックのみの独立テスト可能 |
| **依存性の明示** | 暗黙的で、発見が難しい | 明示的で、構造が一目瞭然 |
| **フレームワーク** | フレームワークに強く依存 | フレームワークは交換可能 |

---

## コア概念と層構造

### 4つの層の詳細解説

クリーンアーキテクチャは、同心円状の4つの層で構成されます。重要な原則は**内側の層は外側の層について全く知らない**ということです。

```
        ┌─────────────────────────────────┐
        │  Frameworks & Drivers           │
        │  (Web, DB, UI, Devices)         │
        │                                 │
        │  ┌─────────────────────────┐   │
        │  │ Interface Adapters      │   │
        │  │ (Controllers, Gateways, │   │
        │  │  Presenters)            │   │
        │  │                         │   │
        │  │  ┌─────────────────┐   │   │
        │  │  │Application      │   │   │
        │  │  │Business Rules   │   │   │
        │  │  │(Use Cases)      │   │   │
        │  │  │                 │   │   │
        │  │  │  ┌───────────┐ │   │   │
        │  │  │  │Enterprise │ │   │   │
        │  │  │  │Business   │ │   │   │
        │  │  │  │Rules      │ │   │   │
        │  │  │  │(Entities) │ │   │   │
        │  │  │  └───────────┘ │   │   │
        │  │  │                 │   │   │
        │  │  └─────────────────┘   │   │
        │  │                         │   │
        │  └─────────────────────────┘   │
        │                                 │
        └─────────────────────────────────┘
```

#### Layer 1: Enterprise Business Rules（エンティティ層）

**役割**：ビジネスの最も基本的なルールを表現する層

**主な特徴**：
- 最も変わりにくい部分
- データとそのデータを操作するメソッドを含むビジネスエンティティを定義
- UIやDBの変更から完全に独立
- プロジェクト固有のビジネスドメイン知識を集約

**具体例**：
- ECサイト：商品（Product）、注文（Order）、顧客（Customer）などのビジネスエンティティ
- これらのエンティティは通常、全社通用のビジネスルールを必須とする

**エンティティが含むもの**：
- ビジネスデータ（属性）
- ビジネスルール（そのデータに対する操作や制約）
- 同じビジネスドメジション内で複数のアプリケーションで再利用される

> **重要**：エンティティはフレームワークに一切依存してはいけません。これが「フレームワーク非依存」を実現する最初のステップです。

#### Layer 2: Application Business Rules（ユースケース層）

**役割**：アプリケーション固有のビジネスロジックを実装する層

**主な特徴**：
- エンティティを使用してアプリケーションの用途（ユースケース）を実現
- UI やDB の変更に直接影響されない
- すべてのアプリケーション固有のビジネスロジックを含む

**具体例**：
- 「新規注文を作成する」ユースケース
  1. 注文入力を検証
  2. 在庫を確認
  3. 決済を処理（外部サービスに委譲）
  4. 注文をDBに保存（外部サービスに委譲）
  5. 確認メールを送信（外部サービスに委譲）

**ユースケース層のポイント**：
- ユースケースはDIP（依存性逆転）を使用して、外部サービス（DB、メール等）を抽象化
- ビジネスロジックは外部サービスの詳細を知らない
- テストは外部サービスをモック化して実行可能

#### Layer 3: Interface Adapters（インターフェース・アダプタ層）

**役割**：外部システムとアプリケーションのビジネスロジックの間の橋渡し

**主な特徴**：
- Web、DB、 UIなどの外部インターフェースの詳細を扱う
- 外部システムのデータフォーマットをアプリケーションが期待する形に変換
- コントローラー、ゲートウェイ、プレゼンター等を含む

**具体的な役割分業**：

| 役割 | 説明 | 例 |
|-----|-----|---|
| **Controller** | HTTP リクエストを受け取り、ユースケースを呼び出し | POST /orders の処理 |
| **Gateway** | DBやAPI呼び出しなどの外部サービスの詳細を実装 | ユースケースが期待するインターフェースを実装 |
| **Presenter** | ビジネスロジックの出力をUI用フォーマットに変換 | JSONレスポンス作成 |

**インターフェース・アダプタ層の意義**：
- ビジネスロジックはこの層の詳細を知らない
- DB実装を変更しても、ビジネスロジックには影響なし
- テストではこの層をモック化して、高速テストを実現

#### Layer 4: Frameworks & Drivers（フレームワーク・ドライバー層）

**役割**：外部ツールやライブラリを統合する最外層

**主な特徴**：
- Web フレームワーク（Spring, Express, ASP.NET 等）
- ORM（Entity Framework, SQLAlchemy 等）
- UI ライブラリ
- 外部API呼び出しライブラリ

**このレイヤーで行うこと**：
- 外部ライブラリの初期化設定
- ルーティング定義
- DBコネクション管理
- 依存性注入（DI）の設定

**このレイヤーで避けるべきこと**：
- ビジネスロジックの記述
- 複数の層を相互参照する複雑な連携

> **ポイント**：このレイヤーは単薄で、内側の層への「翻訳機」としての役割に徹すること。

---

### 層間の依存関係と依存性逆転の原則（DIP）

#### 依存関係の原則

クリーンアーキテクチャの核は、**依存関係の方向**です。

**原則**：
- **外側の層は内側の層に依存してOK**
- **内側の層は外側の層に依存してはいけない**

```
【許可される依存関係】          【禁止される依存関係】
Frameworks → Interface ✓         Interface → Frameworks ✗
Interface → Application ✓        Application → Frameworks ✗
Application → Enterprise ✓       Enterprise → Application ✗
```

**なぜこの方向なのか**：
- 最も重要なビジネスロジック（Enterprise層）を保護する
- ビジネスロジックが外部の変更に影響されない
- テストの際、外部サービスをモック化して独立テスト可能

#### 依存性逆転の原則（DIP）

内側の層が外側の層に依存しないために使われるのが**インターフェース**です。

**例：ユースケースがDB呼び出しが必要な場合**

```
【DIP適用前 - 悪い例】
ユースケース層
    ↓ 直接依存（NG）
DB実装層（SQLServer、MySQL等）

⇒ 問題：ユースケースがDB実装に依存
  DB の詳細変更でユースケースも修正が必要


【DIP適用後 - 良い例】
ユースケース層
    ↓ 依存
IRepository インターフェース（抽象化）
    ↑ 実装
DB実装層（SQLServer、MySQL等）

⇒ 利点：ユースケースは IRepository インターフェースのみ知る
  DB実装の変更は IRepository の実装側のみに影響
  テスト時はモック IRepository で代替可能
```

**DIP の実装パターン**：

内側の層 → インターフェース定義
外側の層 → インターフェース実装

このように**外側が内側で定義されたインターフェースに対して実装を作成**することで、依存関係を逆転させています。

---

### 層間通信メカニズム

#### データの流れ

ユーザーんが操作を行ってからレスポンスを返すまでの全体的な流れを理解しましょう。

```
【HTTP リクエスト処理の流れ】

1. User → HTTP Request (POST /orders)

2. Framework & Drivers 層
   - Route マッチング
   - HTTP パラメータ解析

3. Interface Adapter 層 (Controller)
   - HTTPリクエストデータ → ユースケース入力への変換
   - ユースケース呼び出し

4. Application Business Rules 層 (UseCase)
   - 「注文のDBが存在するか確認」→ Gatewayの IRepository を呼び出し（注：実装は外側）
   - 「決済処理を実行」→ Gatewayの IPaymentService を呼び出し（注：実装は外側）
   - ビジネスロジック実行

5. Interface Adapter 層 (Gateway)
   - IRepository の実装：DB呼び出し
   - IPaymentService の実装：決済API呼び出し

6. Framework & Drivers 層
   - 実際の DBクエリ実行
   - 実際の API 呼び出し

7. Interface Adapter 層 (Presenter)
   - ユースケース結果 → JSON表現に変換

8. Framework & Drivers 層
   - HTTP レスポンス生成

9. User ← HTTP Response (JSON)
```

#### 層を超えたデータの受け渡し

層間でのデータ受け渡しは、**Request / Response オブジェクト**で行います。

**重要なルール**：
- Request / Response は**その層のみ定義**
- 層間を横切る場合、新しい Request / Response を定義
- DB エンティティをそのまま返さない（詳細は後述）

**例**：
```
Presenter から Web Framework へ返すオブジェクト
    ↓
JSON:
{
  "orderId": "ORD123",
  "status": "confirmed"
}

DB エンティティ
    ↓
{
  orderId,
  customerId,
  items: [...],
  createdAt,
  updatedAt,
  internalFlags,  ← 外部に出してはいけない情報
  ...
}
```

Presenter は DB エンティティを直接返さず、**必要な情報だけに絞った Response オブジェクト**を作成します。

---

### ビジネスロジックの中心化

#### なぜビジネスロジックを内側に集約するのか

クリーンアーキテクチャの最大のメリットは、**ビジネスロジックが一箇所に集約される**ことです。

**従来方式での問題**：
```
ビジネスロジックが散在
- Controller に検証ロジック
- Service に計算ロジック
- DBストアドプロシージャに複雑な条件
- JavaScript で UIバリデーション

⇒ 同じロジックが複数箇所に存在（重複）
⇒ 修正時にすべてを更新しないといけない
⇒ テストしにくい
```

**クリーンアーキテクチャでの解決**：
```
ビジネスロジックを Application層に集約
┌─────────────────────────────────┐
│  「注文の妥当性判定」ユースケース  │
│  （唯一の実装場所）               │
│  - 金額計算                      │
│  - 在庫確認条件                  │
│  - 割引ルール                    │
└─────────────────────────────────┘
   ↓                   ↓
 他の層          他のユースケース
 からは          からも参照可能
 参照される       （再利用）
```

**メリット**：
1. **DRY（Don't Repeat Yourself）**: ロジックが1箇所のみ
2. **保守性**: 修正時に1箇所だけ対応
3. **テスト容易性**: ロジックをユニットテストで検証
4. **再利用性**: 複数のユースケースから同じロジックを使用

#### Example: 注文の割引計算

```
従来方式（反例）
━━━━━━━
Controller
  └─ if (customer.isPremium) apply 20% discount
     else if (total > 1000) apply 10% discount

Service
  └─ const discount = calculateDiscount(customer);

Database Trigger
  └─ IF @customerType = 'PREMIUM' THEN @discount = 0.2

JavaScript Validation
  └─ if (customerPremium) { discount = 0.2; }

⇒ 同じ割引ルールが4箇所に存在


クリーンアーキテクチャ（推奨）
━━━━━━━━━━━━━━━━━
Application層・ユースケース（唯一の実装）
  ┌─────────────────────────────────┐
  │ DiscountPolicy.calculate()      │
  │  - Premium顧客: 20% discount    │
  │  - 1000円以上: 10% discount     │
  │  - その他: なし                  │
  └─────────────────────────────────┘
    ↓                  ↓
  他のユースケース   UI計算用に展開可
                   （Presenter経由）
```

---

## 実演チェック

このセクションを読んで、次の問いに答えられるか確認してください。

1. **依存性逆転の原則（DIP）とは何か、簡潔に説明できますか？**
   - ヒント：「インターフェース」と「内側が外側に依存しない」がキーワード

2. **SOLID 原則とクリーンアーキテクチャの関係は何ですか？**
   - ヒント：理論 vs 実践

3. **4つの層を、簡単に説明できますか？**
   - ヒント：エンティティ → ユースケース → アダプタ → フレームワーク

4. **従来の多層アーキテクチャとクリーンアーキテクチャの最大の違いは何ですか？**
   - ヒント：依存関係の方向を考えてください

5. **クリーンアーキテクチャを導入する最大のメリットは何ですか？**
   - ヒント：「テスト」「保守」「変更」のキーワードを含める

---

## まとめ

STEP 1では、クリーンアーキテクチャの**理論的な基盤**を学びました。

### 重要な学習ポイント

✓ クリーンアーキテクチャは「ビジネスロジックを詳細から独立させ、保守性が高いコードを実現する」設計思想  
✓ 4つの層（Enterprise → Application → Interface Adapters → Frameworks）で構成  
✓ 依存関係は内側へのみ向く（外側は内側に依存してOK、その逆はNG）  
✓ DIP（依存性逆転）でインターフェースを使用し、内側が外側に依存しない仕組みを実現  
✓ SOLID 原則が理論的基礎  

### 次のステップへ

このステップで学んだ**理論的枠組み**を、STEP 2では**設計方法論**として展開します。
- エンティティ層をどう設計するのか
- ユースケース層をどう構造化するのか
- インターフェース・アダプタ層のパターン
- 実装パターンと DI 戦略

---

## 参考リソース

### このSTEPの確認ポイント
- クリーンアーキテクチャが何を解決しようとしているかが理解できたか
- 4つの層の役割が明確に説明できるか
- 依存性の方向性（内側へのみ）が理由とともに説明できるか
- SOLID 原則との繋がりが見えているか

### 関連するSTEP
- **STEP 2: 設計方法論** ← 次は設計の具体的方法論
- **STEP 3: 言語別実装** ← さらに先の実装フェーズ
- **STEP 4: 適用判断** ← 導入の判断基準
- **STEP 5: 実践応用** ← 実装例とアンチパターン

### 外部リソース
- **Clean Architecture: A Craftsman's Guide to Software Structure and Design**  
  Robert C. Martin著。クリーンアーキテクチャの原著。図解が豊富で推奨。

- **Uncle Bob's Blog - The Clean Architecture**  
  https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html  
  原著者による直接的な説明。同心円図はここから。

- **Martin Fowler's Blog - Architecture**  
  https://martinfowler.com/  
  アーキテクチャに関する深い分析。参考になります。

### STEP 1 の振り返り

**このステップを完了したので、以下を理解していること：**
- アーキテクチャの目的と重要性
- 4つの層の概念的理解
- 依存性逆転の原則
- SOLID との関連

**次のSETEP 2では以下を学べます：**
- 各層を実装する際の具体的パターン
- インターフェース設計の戦略
- ユースケース層の構造化方法
---

**[STEP 2へ進む]** → STEP 2: 設計方法論では、ここで学んだ理論を実装パターンとして展開します。
