{
  "id": "clean-architecture-step4",
  "title": "クリーンアーキテクチャ STEP 4: 適用判断",
  "description": "メリット・課題・適用判断基準、段階的導入戦略を学ぶ",
  "difficulty": "初級～中級",
  "questions": [
    {
      "options": [
        {
          "text": "開発初期の速度が劇的に向上する"
        },
        {
          "text": "テスト容易性とビジネスロジックの再利用性が向上し、長期的な保守コストが大幅に削減される"
        },
        {
          "text": "コードの行数が減少する"
        },
        {
          "text": "フレームワークの動作が高速化される"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャ最大のメリットは長期的な効果です。テスト容易性により、修正時の信頼性が向上し、バグの減少、テスト実行時間の大幅短縮が実現されます。また、ビジネスロジックがUI非依存なため、複数プラットフォームでの再利用が可能になります。",
      "id": "step4-judgment-001",
      "question": "クリーンアーキテクチャの導入メリットで最も大きいものはどれか？"
    },
    {
      "options": [
        {
          "text": "テスト実行時間：8秒 → 0.5秒（16倍高速化）"
        },
        {
          "text": "テストカバレッジ：45% → 85% に向上"
        },
        {
          "text": "両方上記が期待できる"
        },
        {
          "text": "テストの改善は期待できない"
        }
      ],
      "correctOptionIndex": 2,
      "explanation": "クリーンアーキテクチャでビジネスロジックがUIやDBから独立するため、テストが非常に高速になり（モック化のため）、同時に書きやすくなるためカバレッジも向上します。CI/CD パイプラインが5分→30秒に改善された例も多くあります。",
      "id": "step4-judgment-002",
      "question": "クリーンアーキテクチャのテスト容易性による実際の改善効果で、最も期待できるものはどれか？"
    },
    {
      "options": [
        {
          "text": "実装のコード行数が増加する可能性がある"
        },
        {
          "text": "チームの学習コストが高く、初期段階では開発速度が低下する"
        },
        {
          "text": "特に課題はない"
        },
        {
          "text": "フレームワークの動作が遅くなる"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャの導入課題は学習コストと初期段階での開発速度低下です。設計に時間をかける必要があり、抽象化層が増えるため初期開発は遅くなります。ただし、2-3ヶ月後に改善効果が顕著になります。",
      "id": "step4-judgment-003",
      "question": "クリーンアーキテクチャ導入時の課題として、最も深刻なものはどれか？"
    },
    {
      "options": [
        {
          "text": "Spring → Quarkus への移行時、ビジネスロジック層への影響が最小化される"
        },
        {
          "text": "フレームワークの変更は不可能である"
        },
        {
          "text": "全てのコード修正が不要である"
        },
        {
          "text": "フレームワークを変更する必要はない"
        }
      ],
      "correctOptionIndex": 0,
      "explanation": "クリーンアーキテクチャでは、Adapter層とFramework層のみの変更でフレームワークを切り替え可能です。例えば、Spring から Quarkus への移行時、ビジネスロジック（Domain・Application層）は変更不要で、Adapter層（Controller、Repository実装）のみを修正すれば対応できます。",
      "id": "step4-judgment-004",
      "question": "フレームワーク独立性のメリットについて、最も実現可能な例はどれか？"
    },
    {
      "options": [
        {
          "text": "Web UI のみのサポートに限定される"
        },
        {
          "text": "複数のUI（Web、Mobile、CLI、バッチ）から同じユースケースを呼び出せることで、機能重複を防ぎ、保守効率が向上する"
        },
        {
          "text": "UI によってビジネスロジックを分割する必要がある"
        },
        {
          "text": "UI トレーディング機は不要である"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャでは、Application層のユースケースがUI非依存なため、Web UI、モバイルアプリ、CLI ツール、バッチ処理などから同じビジネスロジックを呼び出せます。機能重複を避けられ、バグ修正が1箇所で済みます。",
      "id": "step4-judgment-005",
      "question": "ビジネスロジックの再利用性について、クリーンアーキテクチャのメリットはどれか？"
    },
    {
      "options": [
        {
          "text": "大規模プロジェクトには必要だが、小規模プロジェクトには不要である"
        },
        {
          "text": "両方ともクリーンアーキテクチャを導入すべきである"
        },
        {
          "text": "大規模プロジェクトには導入し、小規模プロジェクトは段階的導入または導入を見送るべき"
        },
        {
          "text": "小規模プロジェクトをお薦め、大規模はシンプルに"
        }
      ],
      "correctOptionIndex": 2,
      "explanation": "大規模で長期的なプロジェクトはクリーンアーキテクチャの導入が強く推奨されます。一方、小規模で短期的なプロジェクト（MVP等）はクリーンアーキテクチャための学習コストが見合わない可能性があるため、段階的導入または導入を見送るべきです。",
      "id": "step4-judgment-006",
      "question": "クリーンアーキテクチャの導入判断について、『大規模で長期的に保守するプロジェクト』と『小規模で短期的なプロジェクト』の判定で、最も正しいものはどれか？"
    },
    {
      "options": [
        {
          "text": "マイクロサービスなので、クリーンアーキテクチャは不要である"
        },
        {
          "text": "各マイクロサービス内でクリーンアーキテクチャを適用し、独立したビジネスロジックを実装すべき"
        },
        {
          "text": "すべてのマイクロサービスを1つのクリーンアーキテクチャで統合する"
        },
        {
          "text": "フレームワークのみで実装し、アーキテクチャ設計は不要である"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "マイクロサービスアーキテクチャと クリーンアーキテクチャは相補的です。各マイクロサービス内でクリーンアーキテクチャを適用することで、独立したビジネスロジック、テスト容易性、技術スタックの柔軟性が実現されます。",
      "id": "step4-judgment-007",
      "question": "プロジェクト規模によるクリーンアーキテクチャの適用判断で、『マイクロサービスアーキテクチャ』の場合、どのような対応が推奨されるか？"
    },
    {
      "options": [
        {
          "text": "経験浅いチームは，クリーンアーキテクチャを導入すべきではない"
        },
        {
          "text": "段階的導入、教育・コードレビューを十分に実施し、学習コストを投資すべき"
        },
        {
          "text": "フレームワークのみで実装し、アーキテクチャ設計は経験者のみが行う"
        },
        {
          "text": "クリーンアーキテクチャは高度すぎるため、シンプル手法に限定する"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "経験浅いチームでもクリーンアーキテクチャは導入可能ですが、学習期間を設けて、段階的に導入することが重要です。コードレビュー、アーキテクチャ設計ドキュメント、チームトレーニングを通じて、基礎知識を定着させた上で導入すべきです。",
      "id": "step4-judgment-008",
      "question": "チーム構成による適用判断で、『経験の浅い開発者が多いチーム』にクリーンアーキテクチャを導入する場合の注意点は何か？"
    },
    {
      "options": [
        {
          "text": "現在のコード全体を一度にクリーンアーキテクチャにリファクタリングする"
        },
        {
          "text": "新機能から段階的にクリーンアーキテクチャを適用し、既存コードは徐々にリファクタリングする"
        },
        {
          "text": "既存レガシーコードはそのままにして、新しい機能も同じ方式で実装する"
        },
        {
          "text": "レガシーコードがあるなら、クリーンアーキテクチャの導入は不可能である"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "レガシーコード一括変更はリスクが高いため、新機能から段階的にクリーンアーキテクチャを適用することが推奨されます。新コードが『規範』となり、既存コードは修正時にリファクタリングしていく『ボーイスカウト・ルール』が有効です。",
      "id": "step4-judgment-009",
      "question": "既存レガシーコードへのクリーンアーキテクチャ導入について、最も実現的なアプローチはどれか？"
    },
    {
      "options": [
        {
          "text": "ビジネス変更に対応できないため、不向きである"
        },
        {
          "text": "非常に向いている。ビジネスロジックが独立しているため、要件変化への対応が容易である"
        },
        {
          "text": "向いているかどうかはビジネス内容に依存する"
        },
        {
          "text": "クリーンアーキテクチャは不変な設計なので、変更要件には対応できない"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャは頻繁なビジネス変更に非常に向いています。ビジネスロジック（Domain・Application層）が独立しているため、UI や DB の変更から影響を受けず、要件変化への迅速な対応が可能です。",
      "id": "step4-judgment-010",
      "question": "ビジネス要件による適用判断で、『ビジネス要件が頻繁に変わるプロジェクト』にクリーンアーキテクチャは向いているか？"
    },
    {
      "options": [
        {
          "text": "全プロジェクトのリスク軽減"
        },
        {
          "text": "学習・検証のコストが最小化され、成功パターンをチームで共有できる"
        },
        {
          "text": "フレームワークの選択を先延ばしにできる"
        },
        {
          "text": "段階的導入はリスクが高い"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "小規模モジュール（例：特定の機能）でクリーンアーキテクチャを試行することで、チーム全体が習得でき、問題点も早期に発見できます。成功パターンをテンプレート化し、他の機能に横展開することで、全体導入時のリスクが低下します。",
      "id": "step4-judgment-011",
      "question": "段階的導入戦略について、『小規模なモジュール』からクリーンアーキテクチャを適用する場合の利点はどれか？"
    },
    {
      "options": [
        {
          "text": "高度なチーム + 長期プロジェクト + 複雑なビジネス"
        },
        {
          "text": "初級チーム + 1ヶ月の短期 MVP"
        },
        {
          "text": "中級チーム + 6ヶ月プロジェクト + 中程度の複雑性"
        },
        {
          "text": "全ての組み合わせで推奨される"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "初級チーム＋短期 MVP（1ヶ月）の組み合わせは、クリーンアーキテクチャの導入見送りが合理的です。学習コストとビジネス時間の制約が、そのメリットを上回ります。ただし、段階的導入（新機能から適用）は検討の余地があります。",
      "id": "step4-judgment-012",
      "question": "中級問題：プロジェクトのクリーンアーキテクチャ適用判断で、『チームの技術レベル』『プロジェクト期間』『ビジネス複雑性』の3つの要因を総合的に評価する場合、導入を見送るべき組み合わせはどれか？"
    },
    {
      "options": [
        {
          "text": "言語ごとにで異なるアーキテクチャが必要である"
        },
        {
          "text": "計層（Domain・Application）が言語非依存な概念なため、複数言語でも一貫した設計が可能である"
        },
        {
          "text": "言語の違いで、アーキテクチャを無視できる"
        },
        {
          "text": "追加の言語サポートは不可能である"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャの層概念（Domain、Application、Adapter、Framework）は言語非依存です。複数言語のマイクロサービスでも、同じアーキテクチャ原則を適用でき、チーム全体で一貫した設計、コードレビュー基準が維持されます。",
      "id": "step4-judgment-013",
      "question": "中級問題：複数の言語（C#、TypeScript、Java）によるマイクロサービスを構築する場合、クリーンアーキテクチャ導入の利点として最も大きいものはどれか？"
    },
    {
      "options": [
        {
          "text": "完全なクリーンアーキテクチャを適用する"
        },
        {
          "text": "層の簡略版（Domain・Application・Adapter のみ）を適用し、不要な抽象化は避ける"
        },
        {
          "text": "アーキテクチャなしで、フレームワークのみで実装する"
        },
        {
          "text": "複雑性とは無関係である"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "シンプルな CRUD 操作のみの場合、完全なクリーンアーキテクチャは過度な複雑性になる可能性があります。基本的な層分離（Domain・Application・Adapter）に限定し、複雑なPort・Adapter パターンは避けることで、バランスが取れます。",
      "id": "step4-judgment-014",
      "question": "中級問題：ビジネス複雑性が『低い（シンプルなCRUD操作）』場合、クリーンアーキテクチャの過度な複雑性を避けるための戦略はどれか？"
    },
    {
      "options": [
        {
          "text": "1年以内にレガシーコード全体をリファクタリングする"
        },
        {
          "text": "1. 新機能からクリーンアーキテクチャを適用 2. 既存コードは修正時にリファクタリング 3. 2年～3年かけて段階的に統一"
        },
        {
          "text": "レガシーコードはそのままにして、新コード（別アプリケーション）として実装"
        },
        {
          "text": "クリーンアーキテクチャ導入は不可能である"
        }
      ],
      "correctOptionIndex": 1,
      "explanation": "現実的なロードマップは、新機能から段階的にクリーンアーキテクチャを適用し、既存コードは修正時にリファクタリングする方式です。一括変更はリスクが高いため、数年かけて徐々に統一することが推奨されます。",
      "id": "step4-judgment-015",
      "question": "中級問題：既存レガシーコードの参考に、クリーンアーキテクチャ導入を検討する場合、最も現実的なロードマップはどれか？"
    }
  ]
}