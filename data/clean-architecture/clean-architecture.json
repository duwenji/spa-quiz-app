{
  "questions": [
    {
      "id": "ca-001",
      "question": "クリーンアーキテクチャを提唱した人物は誰ですか？",
      "options": [
        {
          "id": "A",
          "text": "Robert C. Martin（Uncle Bob）"
        },
        {
          "id": "B",
          "text": "Martin Fowler"
        },
        {
          "id": "C",
          "text": "Eric Evans"
        },
        {
          "id": "D",
          "text": "Gang of Four"
        }
      ],
      "correctAnswer": "A",
      "explanation": "クリーンアーキテクチャはRobert C. Martin（Uncle Bobとして知られている）によって提唱されました。彼は著作「Clean Architecture」でこの概念を体系化しました。"
    },
    {
      "id": "ca-002",
      "question": "クリーンアーキテクチャの主な目的は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "パフォーマンス最適化を最優先にする"
        },
        {
          "id": "B",
          "text": "ビジネスロジックをフレームワークから独立させ、テストと保守性を向上させる"
        },
        {
          "id": "C",
          "text": "可能な限りフレームワークを活用する"
        },
        {
          "id": "D",
          "text": "データベース設計を簡潔にする"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャの核となる目的は、ビジネスロジックをフレームワークやライブラリから独立させ、テスト容易性と保守性を大幅に向上させることです。"
    },
    {
      "id": "ca-003",
      "question": "クリーンアーキテクチャにおける従来のアーキテクチャとの最大の違いは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "層の数が増える"
        },
        {
          "id": "B",
          "text": "依存関係の方向が、外側から内側への一方向であること"
        },
        {
          "id": "C",
          "text": "より多くのデザインパターンを使用する"
        },
        {
          "id": "D",
          "text": "マイクロサービスアーキテクチャに準拠している"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャの特徴は、外側の層は内側の層に依存しますが、内側の層は外側に依存しません。これが依存性逆転の原則を実現します。"
    },
    {
      "id": "ca-004",
      "question": "SOLID原則のうち、クリーンアーキテクチャの基礎となる原則はどれですか？",
      "options": [
        {
          "id": "A",
          "text": "一つのみ（S原則）"
        },
        {
          "id": "B",
          "text": "複数の原則で構成されている"
        },
        {
          "id": "C",
          "text": "DRY（Don't Repeat Yourself）原則"
        },
        {
          "id": "D",
          "text": "KISS（Keep It Simple, Stupid）原則"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャはSOLID原則全体（S、R、O、L、I）を基礎としており、特に依存性逆転の原則（DIP）が重要な役割を果たしています。"
    },
    {
      "id": "ca-005",
      "question": "クリーンアーキテクチャの4つの主要な層を外側から順番に並べた場合、正しい順序はどれですか？",
      "options": [
        {
          "id": "A",
          "text": "Entities → UseCases → Interface Adapters → Frameworks & Drivers"
        },
        {
          "id": "B",
          "text": "Frameworks & Drivers → Interface Adapters → UseCases → Entities"
        },
        {
          "id": "C",
          "text": "Interface Adapters → Entities → Frameworks & Drivers → UseCases"
        },
        {
          "id": "D",
          "text": "UseCases → Frameworks & Drivers → Entities → Interface Adapters"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャの層は、最も外側から順に：Frameworks & Drivers（フレームワーク・ドライバー）→ Interface Adapters（インターフェース・アダプタ）→ UseCases（ユースケース）→ Entities（エンティティ）となります。"
    },
    {
      "id": "ca-006",
      "question": "Entities層の主な責務は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "ユーザーインターフェースの操作を処理する"
        },
        {
          "id": "B",
          "text": "ビジネスルールを表現し、副作用がない純粋なロジックを実装する"
        },
        {
          "id": "C",
          "text": "データベースとの通信を管理する"
        },
        {
          "id": "D",
          "text": "外部ライブラリを統合する"
        }
      ],
      "correctAnswer": "B",
      "explanation": "Entities層は、アプリケーションのコアであるビジネスルールを表現し、副作用がない純粋で再利用可能なロジックを実装します。外部ライブラリに依存しません。"
    },
    {
      "id": "ca-007",
      "question": "UseCases層の主な責務は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "ビジネスルール自体を定義する"
        },
        {
          "id": "B",
          "text": "アプリケーション固有のビジネスルールを実装し、エンティティを組織して使用する"
        },
        {
          "id": "C",
          "text": "ユーザーインターフェースを直接操作する"
        },
        {
          "id": "D",
          "text": "フレームワークの設定を管理する"
        }
      ],
      "correctAnswer": "B",
      "explanation": "UseCases層は、アプリケーション固有のビジネスルール（エンティティとビジネスルールから直接導出される）を実装し、エンティティを組織して利用します。"
    },
    {
      "id": "ca-008",
      "question": "Interface Adapters層が担当する機能として正しいものはどれですか？",
      "options": [
        {
          "id": "A",
          "text": "ビジネスロジックの実装"
        },
        {
          "id": "B",
          "text": "プレゼンテーション層とデータベース層の間の変換・仲介"
        },
        {
          "id": "C",
          "text": "ユーザーへの表示のみ"
        },
        {
          "id": "D",
          "text": "フレームワークの初期化"
        }
      ],
      "correctAnswer": "B",
      "explanation": "Interface Adapters層は、使用者と内側の層を仲介し、外部形式（UI、DB、外部API）と内側層の形式を変換する責務を持ちます。コントローラー、プレゼンター、ゲートウェイなどが含まれます。"
    },
    {
      "id": "ca-009",
      "question": "Frameworks & Drivers層の主な役割は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "ビジネスロジックの中核を実装する"
        },
        {
          "id": "B",
          "text": "外部ライブラリの統合とアプリケーションの起動設定"
        },
        {
          "id": "C",
          "text": "ユースケースの定義"
        },
        {
          "id": "D",
          "text": "エンティティの予定変更"
        }
      ],
      "correctAnswer": "B",
      "explanation": "Frameworks & Drivers層は、フレームワーク、外部ライブラリ、DI（依存性注入）の設定、そしてすべての配線を含みます。最も外側の層で、変更頻度が最も高い層です。"
    },
    {
      "id": "ca-010",
      "question": "クリーンアーキテクチャにおける依存性逆転の原則（DIP）とは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "内側の層が外側の層に依存すること"
        },
        {
          "id": "B",
          "text": "外側の層が抽象化（インターフェース）に依存することで、具体実装への依存を逆転させる"
        },
        {
          "id": "C",
          "text": "すべての層が同じレベルの依存関係を持つ"
        },
        {
          "id": "D",
          "text": "依存関係をなくすこと"
        }
      ],
      "correctAnswer": "B",
      "explanation": "依存性逆転の原則は、高いレベルのモジュールが低いレベルのモジュールに依存せず、両者が抽象化に依存することにより、結果的に依存関係を逆転させます。"
    },
    {
      "id": "ca-011",
      "question": "Input Port（入力ポート）の役割は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "USeCases層が外部から呼ばれるためのインターフェース"
        },
        {
          "id": "B",
          "text": "データベースへのアクセスポイント"
        },
        {
          "id": "C",
          "text": "ユーザーインターフェースの描画"
        },
        {
          "id": "D",
          "text": "フレームワークの設定"
        }
      ],
      "correctAnswer": "A",
      "explanation": "Input Port（Driving Port）は、UseCases層への入り口インターフェースです。Controllers や CLI などの外側の要素から UseCase を呼ぶための仲介役となります。"
    },
    {
      "id": "ca-012",
      "question": "Output Port（出力ポート）の役割は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "ユースケースから外側の層（DB、外部API）への依存を逆転させるインターフェース"
        },
        {
          "id": "B",
          "text": "ユーザーへの直接の表示"
        },
        {
          "id": "C",
          "text": "フレームワークの初期化"
        },
        {
          "id": "D",
          "text": "エンティティの定義"
        }
      ],
      "correctAnswer": "A",
      "explanation": "Output Port（Driven Port）は、UseCases層がリポジトリやプレゼンターのような外側の要素を使用する際に必要なインターフェースです。これにより、UseCases層は具体実装に依存しません。"
    },
    {
      "id": "ca-013",
      "question": "クリーンアーキテクチャにおいて、Entities層が外部ライブラリに依存しない理由は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "パフォーマンスを最適化するため"
        },
        {
          "id": "B",
          "text": "ビジネスルールを純粋に保ち、再利用性と独立性を確保するため"
        },
        {
          "id": "C",
          "text": "複雑性を減らすため"
        },
        {
          "id": "D",
          "text": "コードの行数を削減するため"
        }
      ],
      "correctAnswer": "B",
      "explanation": "Entities層がフレームワークやライブラリに依存しないことで、ビジネスルールが純粋で独立し、どのアプリケーション、フレームワークでも再利用可能になります。"
    },
    {
      "id": "ca-014",
      "question": "単一責務の原則（SRP）がクリーンアーキテクチャにおいて重要な理由は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "コードの行数を減らすため"
        },
        {
          "id": "B",
          "text": "各層が変更される理由が異なることで、変更の影響範囲を限定できるため"
        },
        {
          "id": "C",
          "text": "パフォーマンスが向上するため"
        },
        {
          "id": "D",
          "text": "ビジネスロジックが簡潔になるため"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャでは、各層が異なる理由で変更されます。SRPにより各層の変更が他の層に波及しないようにします。例えば、ビジネスルールの変更はUI変更の影響を受けません。"
    },
    {
      "id": "ca-015",
      "question": "クリーンアーキテクチャがテスト容易性を向上させる仕組みは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "より多くのテストコードを書くことで"
        },
        {
          "id": "B",
          "text": "層の分離とポート/アダプターパターンにより、ビジネスロジックをフレームワークなしでテストできるため"
        },
        {
          "id": "C",
          "text": "テストツールの選択肢が増えるため"
        },
        {
          "id": "D",
          "text": "テストカバレッジが自動的に増加するため"
        }
      ],
      "correctAnswer": "B",
      "explanation": "層の分離により、ビジネスロジック（UseCasesとEntities）をフレームワークやDB、UIなしで単体テストできます。Output Portはモック化しやすく、統合テストも容易になります。"
    },
    {
      "id": "ca-016",
      "question": "クリーンアーキテクチャにおけるリポジトリパターンの位置付けは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "Entities層の中に実装される"
        },
        {
          "id": "B",
          "text": "Output PortとしてインターフェースがUseCases層に定義され、具体実装がInterface Adapters層にある"
        },
        {
          "id": "C",
          "text": "Frameworks & Drivers層の最上位概念"
        },
        {
          "id": "D",
          "text": "UseCases層と直接統合される"
        }
      ],
      "correctAnswer": "B",
      "explanation": "リポジトリパターンはクリーンアーキテクチャに組み込まれています。UseCases層はリポジトリインターフェース（Output Port）に依存し、具体的なDB実装はInterface Adapters層に配置されます。"
    },
    {
      "id": "ca-017",
      "question": "C#でクリーンアーキテクチャを実装する場合、プロジェクト構成の推奨レイアウトはどれですか？",
      "options": [
        {
          "id": "A",
          "text": "すべてのコードを1つのプロジェクトに配置する"
        },
        {
          "id": "B",
          "text": "Domain、Application、Infrastructure、Web など複数のプロジェクトに分離する"
        },
        {
          "id": "C",
          "text": "フォルダ構成のみで層を分離する"
        },
        {
          "id": "D",
          "text": "フレームワークに合わせた自動生成パターン"
        }
      ],
      "correctAnswer": "B",
      "explanation": "C#ではソリューション内に複数のプロジェクトに分離することが一般的です。Domain（Entities）→ Application（UseCases）→ Infrastructure（Adapters）→ Web/API（Frameworks）という層別プロジェクト構成が推奨されます。"
    },
    {
      "id": "ca-018",
      "question": "C#の依存性注入（DI）コンテナの役割は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "ビジネスロジックを実装する"
        },
        {
          "id": "B",
          "text": "オブジェクトの生成と依存関係の解決を自動化し、Frameworks & Drivers層で配線する"
        },
        {
          "id": "C",
          "text": "データベースへのアクセスを最適化する"
        },
        {
          "id": "D",
          "text": "ユーザーインターフェースを管理する"
        }
      ],
      "correctAnswer": "B",
      "explanation": "DI コンテナ（例：Microsoft.Extensions.DependencyInjection）は、インターフェース（Output Port）と実装（Adapter）の対応付けを設定し、依存関係を自動的に解決します。Frameworks & Drivers層で設定されます。"
    },
    {
      "id": "ca-019",
      "question": "C#の Entity Framework とクリーンアーキテクチャの関係は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "Entity Framework は Entities層で使用される"
        },
        {
          "id": "B",
          "text": "Entity Framework は Infrastructure層（Interface Adapters）でリポジトリを実装する際に使用される"
        },
        {
          "id": "C",
          "text": "Entity Framework はアーキテクチャに直接影響しない"
        },
        {
          "id": "D",
          "text": "Entity Framework はビジネスロジックの一部"
        }
      ],
      "correctAnswer": "B",
      "explanation": "Entity Framework は Infrastructure層でリポジトリの具体実装として使用され、Interface Adapters の一部です。ビジネスロジック（Entities, UseCases）からは分離されています。"
    },
    {
      "id": "ca-020",
      "question": "TypeScript/JavaScript でクリーンアーキテクチャの層を分離する方法として最も適切なものは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "フォルダ構成のみで層を論理的に分離する"
        },
        {
          "id": "B",
          "text": "複数のプロジェクト（monorepo）に分割する"
        },
        {
          "id": "C",
          "text": "フォルダ構成とモジュール/バレルファイル（index.ts）で分離し、import パスで依存関係を制御する"
        },
        {
          "id": "D",
          "text": "フレームワークのデフォルト構造に従う"
        }
      ],
      "correctAnswer": "C",
      "explanation": "TypeScript では、フォルダ構成で層を分離し、各層の index.ts（バレルファイル）を使用して公開するインターフェースを明確にします。import ルールで依存方向を制御することで、層の分離を実現します。"
    },
    {
      "id": "ca-021",
      "question": "TypeScript でインターフェースの抽象化を実現する場合、どのようなパターンが有効ですか？",
      "options": [
        {
          "id": "A",
          "text": "クラスのみを使用する"
        },
        {
          "id": "B",
          "text": "TypeScript のインターフェース（interface）を定義し、UseCases層はインターフェースに依存させ、具体実装は Interface Adapters層に配置する"
        },
        {
          "id": "C",
          "text": "すべてのコードを plain objects で実装する"
        },
        {
          "id": "D",
          "text": "abstract クラスのみを使用する"
        }
      ],
      "correctAnswer": "B",
      "explanation": "TypeScript のインターフェース（interface）は抽象化のための強力なツールです。これを使用して Input Port と Output Port を定義し、UseCases層は具体実装ではなくインターフェースに依存させます。"
    },
    {
      "id": "ca-022",
      "question": "TypeScript で React/Vue の統合を行う場合、フレームワークはどの層に配置されるべきですか？",
      "options": [
        {
          "id": "A",
          "text": "UseCases層"
        },
        {
          "id": "B",
          "text": "Frameworks & Drivers層"
        },
        {
          "id": "C",
          "text": "Entities層"
        },
        {
          "id": "D",
          "text": "すべての層に分散される"
        }
      ],
      "correctAnswer": "B",
      "explanation": "React や Vue は UI フレームワークであり、Frameworks & Drivers層に配置されます。ビジネスロジック（UseCases）から独立しており、カスタムフック（useQuiz など）を通じてビジネスロジックを呼び出します。"
    },
    {
      "id": "ca-023",
      "question": "TypeScript での依存性注入の実装方法として、C#のような DI コンテナを使わない場合、どのパターンが有効ですか？",
      "options": [
        {
          "id": "A",
          "text": "グローバル変数を使用する"
        },
        {
          "id": "B",
          "text": "コンストラクタインジェクションまたはファクトリーパターンを手動で実装する"
        },
        {
          "id": "C",
          "text": "すべての依存関係をハードコーディングする"
        },
        {
          "id": "D",
          "text": "依存性注入を使用しない"
        }
      ],
      "correctAnswer": "B",
      "explanation": "TypeScript では、Reflect メタデータライブラリを使わない場合、コンストラクタインジェクション（オブジェクト生成時に依存を注入）またはファクトリーパターン（オブジェクト生成を専門化する）で実装します。"
    },
    {
      "id": "ca-024",
      "question": "Java でクリーンアーキテクチャを実装する場合、パッケージ構成の推奨レイアウトはどれですか？",
      "options": [
        {
          "id": "A",
          "text": "機能ごとのパッケージ分割（entity, usecase, controller など）"
        },
        {
          "id": "B",
          "text": "層ごとのパッケージ分割（domain, application, infrastructure, web など）"
        },
        {
          "id": "C",
          "text": "単一のパッケージに全て配置"
        },
        {
          "id": "D",
          "text": "フレームワークが定義したパッケージ構成のみ"
        }
      ],
      "correctAnswer": "B",
      "explanation": "Java ではパッケージで層を分離することが一般的です。com.myapp.domain, com.myapp.application, com.myapp.infrastructure, com.myapp.web などの階層構成により、依存関係を制御します。"
    },
    {
      "id": "ca-025",
      "question": "Java で Spring Framework を使用する場合、アノテーションによる DI 設定の先代理は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "ビジネスロジックに Spring アノテーション（@Autowired, @Service など）を直接記述する"
        },
        {
          "id": "B",
          "text": "UseCases層は Spring に依存させず、Frameworks層で DI 設定をする"
        },
        {
          "id": "C",
          "text": "Spring は Infrastructure層でのみ使用される"
        },
        {
          "id": "D",
          "text": "すべてのコンポーネントに @Autowired を付与する"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャでは、UseCases層は Spring に依存すべきではありません。@Configuration クラスを使用して Frameworks層で DI を設定することで、ビジネスロジックをフレームワークから独立させます。"
    },
    {
      "id": "ca-026",
      "question": "クリーンアーキテクチャを適用する最大のメリットは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "開発速度が必ず速くなる"
        },
        {
          "id": "B",
          "text": "テスト容易性の向上と長期的な保守コストの削減"
        },
        {
          "id": "C",
          "text": "バグが完全に排除される"
        },
        {
          "id": "D",
          "text": "フレームワークの選択肢が増える"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャの最大のメリットは、層の分離によってテスト容易性が大幅に向上し、長期的にビジネスロジックの変更や技術スタック変更時のコストが削減されることです。"
    },
    {
      "id": "ca-027",
      "question": "クリーンアーキテクチャを適用する際の主な課題は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "必要なライブラリが少ない"
        },
        {
          "id": "B",
          "text": "過度な抽象化による複雑性の増加と、小規模プロジェクトでの導入判断の難しさ"
        },
        {
          "id": "C",
          "text": "パフォーマンスが常に低下する"
        },
        {
          "id": "D",
          "text": "チームの技術スキルが必要ない"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャは過度に設計されると複雑になり、小規模プロジェクトではオーバーエンジニアリングになる可能性があります。また、チームのスキルレベルに応じた実装が必要です。"
    },
    {
      "id": "ca-028",
      "question": "ビジネスロジックの再利用性がクリーンアーキテクチャで向上する理由は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "フレームワークの選択肢が増えるから"
        },
        {
          "id": "B",
          "text": "ビジネスロジックがフレームワークやプラットフォームから独立しているから"
        },
        {
          "id": "C",
          "text": "より多くのプロジェクトを使用するから"
        },
        {
          "id": "D",
          "text": "コードの行数が少なくなるから"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャでは、ビジネスロジック（Entities、UseCases）がフレームワークやプラットフォームに依存しないため、異なるアプリケーション（Web、Mobile、CLI など）で同じビジネスロジックを再利用できます。"
    },
    {
      "id": "ca-029",
      "question": "フレームワーク変更時にクリーンアーキテクチャが有利である理由は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "フレームワークの数が多いから"
        },
        {
          "id": "B",
          "text": "ビジネスロジックがフレームワークから独立しているため、Interface Adapters層のみ変更すれば良いから"
        },
        {
          "id": "C",
          "text": "すべてのコードを書き換える必要がない"
        },
        {
          "id": "D",
          "text": "新しいフレームワークの学習が不要"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャでは、ビジネスロジック（Entities、UseCases）はフレームワークに依存しないため、フレームワーク変更（例：Spring → Quarkus）時は Interface Adapters と Frameworks層のみ修正すれば良く、リスクが大幅に低減されます。"
    },
    {
      "id": "ca-030",
      "question": "チーム全体の保守性がクリーンアーキテクチャで向上する理由は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "開発者が減る"
        },
        {
          "id": "B",
          "text": "各層の責務が明確であり、変更による影響範囲が限定されるため、チーム全体での保守がしやすくなる"
        },
        {
          "id": "C",
          "text": "コードの量が少なくなる"
        },
        {
          "id": "D",
          "text": "バグが発生しなくなる"
        }
      ],
      "correctAnswer": "B",
      "explanation": "責務の明確な層分離により、異なるチームメンバーが異なる層で働いても、影響範囲が限定されるため、チーム全体での開発効率が向上し、保守しやすくなります。"
    },
    {
      "id": "ca-031",
      "question": "小規模プロジェクトでクリーンアーキテクチャを適用する場合の注意点は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "すべての層を厳密に実装する必要がある"
        },
        {
          "id": "B",
          "text": "オーバーエンジニアリングを避け、プロジェクトの複雑度に応じて柔軟に適用すべき"
        },
        {
          "id": "C",
          "text": "小規模プロジェクトでは適用すべきでない"
        },
        {
          "id": "D",
          "text": "フレームワークに頼らず実装する"
        }
      ],
      "correctAnswer": "B",
      "explanation": "小規模プロジェクトではすべての層を厳密に実装する必要はありません。プロジェクローの複雑度、チームのスキル、将来の成長予測に基づいて、フレキシブルに適用することが重要です。"
    },
    {
      "id": "ca-032",
      "question": "クリーンアーキテクチャがパフォーマンスに影響する可能性について、正しい説明はどれですか？",
      "options": [
        {
          "id": "A",
          "text": "クリーンアーキテクチャは必ずパフォーマンスを低下させる"
        },
        {
          "id": "B",
          "text": "層の分離による抽象化オーバーヘッドがあり得るが、適切な設計で最小化できる"
        },
        {
          "id": "C",
          "text": "パフォーマンスには全く影響しない"
        },
        {
          "id": "D",
          "text": "パフォーマンス最適化はアーキテクチャ設計より優先される"
        }
      ],
      "correctAnswer": "B",
      "explanation": "層の分離と抽象化は若干のオーバーヘッドがあるかもしれませんが、適切な設計（不要な中間層を避ける、効率的なデータ構造の使用）で最小化できます。多くの場合、メリットがデメリットを上回ります。"
    },
    {
      "id": "ca-033",
      "question": "クリーンアーキテクチャの採用判断において、最も重要な要素は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "フレームワークの流行度"
        },
        {
          "id": "B",
          "text": "プロジェクトの複雑度、チームのスキル、長期的な保守性の必要性"
        },
        {
          "id": "C",
          "text": "開発期間の長さ"
        },
        {
          "id": "D",
          "text": "予算の多さ"
        }
      ],
      "correctAnswer": "B",
      "explanation": "クリーンアーキテクチャの採用は、プロジェクトの複雑度（今後の拡張予測を含む）、チームのスキルレベル（理解できるか）、保守性の重要度（長期運用か短期か）などを総合的に判断して決定すべきです。"
    },
    {
      "id": "ca-034",
      "question": "完全なサンプルアプリケーションの分析において、どのポイントが最も重要ですか？",
      "options": [
        {
          "id": "A",
          "text": "コードの行数が少ないこと"
        },
        {
          "id": "B",
          "text": "各層の境界が明確で、依存関係が正確に守られているか"
        },
        {
          "id": "C",
          "text": "使用されているライブラリの数"
        },
        {
          "id": "D",
          "text": "最新の技術を使用していること"
        }
      ],
      "correctAnswer": "B",
      "explanation": "サンプルアプリケーションの分析では、各層の責務が正確に分離され、依存関係が内側への一方向に守られているかを確認することが最も重要です。これを理解することで、自分のプロジェクトへの応用が容易になります。"
    },
    {
      "id": "ca-035",
      "question": "クリーンアーキテクチャの実装における最も一般的なアンチパターンは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "フレームワークが Entities層に依存している"
        },
        {
          "id": "B",
          "text": "UseCases層が外側の層に直接依存し、Output Port を使用していない"
        },
        {
          "id": "C",
          "text": "各層が独立している"
        },
        {
          "id": "D",
          "text": "エンティティがビジネスロジックを含まない"
        }
      ],
      "correctAnswer": "B",
      "explanation": "最も一般的なアンチパターンは、UseCases層がリポジトリやプレゼンター等の外側の層に直接依存してしまい、Output Port（インターフェース）を使用しないことです。これにより依存性逆転の原則が破られます。"
    },
    {
      "id": "ca-036",
      "question": "クリーンアーキテクチャにおいて、Entities層が外側の層に依存している場合、何が問題ですか？",
      "options": [
        {
          "id": "A",
          "text": "見た目が悪い"
        },
        {
          "id": "B",
          "text": "ビジネスロジックの独立性と再利用性が失われ、テストが困難になる"
        },
        {
          "id": "C",
          "text": "パフォーマンスが向上する"
        },
        {
          "id": "D",
          "text": "特に問題がない"
        }
      ],
      "correctAnswer": "B",
      "explanation": "Entities層が外側に依存すると、ビジネスロジックが外部フレームワークに結合され、独立してテストできなくなり、再利用性が低下します。これはクリーンアーキテクチャの基本原則に反します。"
    },
    {
      "id": "ca-037",
      "question": "層の混在（複数の層のコードが1つのクラスに混在）が問題である理由は何ですか？",
      "options": [
        {
          "id": "A",
          "text": "コード行数が増える"
        },
        {
          "id": "B",
          "text": "責務の分離が失われ、変更の影響範囲が拡大し、テストが困難になる"
        },
        {
          "id": "C",
          "text": "フレームワークの動作が遅くなる"
        },
        {
          "id": "D",
          "text": "特に問題がない"
        }
      ],
      "correctAnswer": "B",
      "explanation": "層の混在により、単一責務の原則が破られ、複数の理由で変更が発生し、その影響が広がります。また、ビジネスロジック単独でのテストが困難になり、アーキテクチャの利点が失われます。"
    },
    {
      "id": "ca-038",
      "question": "依存性の逆転に失敗した場合のシナリオとして、正しい説明はどれですか？",
      "options": [
        {
          "id": "A",
          "text": "内側の層が外側の層に依存し、変更の波及が大きくなり、テストが困難"
        },
        {
          "id": "B",
          "text": "外側の層がすべての層に依存し、柔軟性が損なわれる"
        },
        {
          "id": "C",
          "text": "層間の循環依存が発生する可能性がある"
        },
        {
          "id": "D",
          "text": "すべてのシナリオとも可能"
        }
      ],
      "correctAnswer": "D",
      "explanation": "依存性の逆転に失敗すると、上記のすべてのシナリオが起こり得ます。これが避けるべき状況であり、クリーンアーキテクチャではInterface/Output Portを使い、この問題を系統的に解決します。"
    },
    {
      "id": "ca-039",
      "question": "リソース制約下（小さなチーム、短い開発期間）でクリーンアーキテクチャを適用する場合の最適なアプローチは何ですか？",
      "options": [
        {
          "id": "A",
          "text": "フルスケールのクリーンアーキテクチャを実装する"
        },
        {
          "id": "B",
          "text": "クリーンアーキテクチャを全く使わない"
        },
        {
          "id": "C",
          "text": "段階的に実装し、最低限の層分離（ビジネスロジックとUI/DB の分離）から始める"
        },
        {
          "id": "D",
          "text": "フレームワークのデフォルト構造のみを使う"
        }
      ],
      "correctAnswer": "C",
      "explanation": "リソース制約下では、フルスケールのクリーンアーキテクチャを追い求めるべきではありません。最初は最小限の層分離（ビジネスロジックの独立、Output Port の概念）から始め、必要に応じて段階的に実装を充実させることが現実的です。"
    }
  ]
}
