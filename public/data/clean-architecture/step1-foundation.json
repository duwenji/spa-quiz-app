{
  "id": "clean-architecture-step1",
  "title": "クリーンアーキテクチャ STEP 1: 理論基盤",
  "description": "クリーンアーキテクチャの基本概念、4つの層構造、SOLID原則との関連性を学ぶ",
  "difficulty": "初級～中級",
  "questions": [
    {
      "text": "クリーンアーキテクチャの3つの主要なゴールとして正しいものはどれか？",
      "options": [
        { "text": "フレームワーク非依存、テスト容易性、保守性と拡張性" },
        { "text": "速度重視、コスト削減、セキュリティ強化" },
        { "text": "ユーザーインターフェース、データベース、ネットワーク統合" },
        { "text": "フレームワーク依存、テスト困難性、短期開発" }
      ],
      "correctOptionIndex": 0,
      "explanation": "クリーンアーキテクチャの3つの目標は、特定のフレームワークに依存しないこと、ビジネスロジックをフレームワークから切り離してテストを容易にすること、そして長期的な保守と変更の容易さを実現することです。"
    },
    {
      "text": "Robert C. Martin（Uncle Bob）がクリーンアーキテクチャを提唱した年はいつか？",
      "options": [
        { "text": "2008年" },
        { "text": "2012年" },
        { "text": "2015年" },
        { "text": "2010年" }
      ],
      "correctOptionIndex": 1,
      "explanation": "Robert C. Martinは2012年にクリーンアーキテクチャという設計哲学を提唱しました。彼はSOLID原則や『Clean Code』などの著作でも知られています。"
    },
    {
      "text": "クリーンアーキテクチャの層構造について正しい説明はどれか？",
      "options": [
        { "text": "上層が下層に依存する従来の多層アーキテクチャと同じ構造である" },
        { "text": "同心円状の4つの層で構成され、内側の層は外側について知らない" },
        { "text": "単一の層だけで全てのビジネスロジックを処理する" },
        { "text": "フレームワークが最も中心で、その周囲にビジネスロジックがある" }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャは同心円状の4つの層（Enterprise Business Rules、Application Business Rules、Interface Adapters、Frameworks & Drivers）で構成されています。重要な原則は、内側の層が外側の層について全く知らないということです。"
    },
    {
      "text": "従来のアーキテクチャとクリーンアーキテクチャの依存関係の方向性について、最も異なる点は何か？",
      "options": [
        { "text": "従来は上から下へ、クリーンは逆に下から上へ依存する" },
        { "text": "従来は上から下へ、クリーンは内側へと依存する" },
        { "text": "従来は横方向、クリーンは縦方向に依存する" },
        { "text": "依存関係の方向性は変わらない" }
      ],
      "correctOptionIndex": 1,
      "explanation": "従来の多層アーキテクチャでは上位層が下位層に依存します。一方、クリーンアーキテクチャでは外側の層が内側に依存する形で、中心のビジネスロジックが外部に依存しないようになっています。"
    },
    {
      "text": "SOLID原則とクリーンアーキテクチャの関係性について最も正しい説明はどれか？",
      "options": [
        { "text": "SOLID原則はクリーンアーキテクチャと無関係である" },
        { "text": "SOLID原則はクリーンアーキテクチャの理論的基礎であり、実装方法である" },
        { "text": "クリーンアーキテクチャはSOLID原則に反するである" },
        { "text": "SOLID原則はクリーンアーキテクチャの後に生まれた" }
      ],
      "correctOptionIndex": 1,
      "explanation": "SOLID原則はクリーンアーキテクチャの理論的基礎です。クリーンアーキテクチャはSOLID原則を実装するための実践的な方法論と言えます。"
    },
    {
      "text": "クリーンアーキテクチャにおいて、アーキテクチャの真の目的は何か？",
      "options": [
        { "text": "開発初期の速度を最大化することである" },
        { "text": "長期的な保守と変更の容易さを実現することである" },
        { "text": "できるだけ多くのデザインパターンを使用することである" },
        { "text": "フレームワークの機能を最大限活用することである" }
      ],
      "correctOptionIndex": 1,
      "explanation": "重要な考え方として、アーキテクチャの真の目的は『開発初期の速度』ではなく『長期的な保守と変更の容易さ』です。設計に時間をかけることで、開発後期での修正コストを削減します。"
    },
    {
      "text": "Single Responsibility（単一責任）原則について、正しい説明はどれか？",
      "options": [
        { "text": "1つのクラスは複数の責任を持つべきである" },
        { "text": "1つのクラスは1つの責任のみを持つべきである" },
        { "text": "1つのクラスは全てのビジネスロジックを含むべきである" },
        { "text": "責任の分離は不要である" }
      ],
      "correctOptionIndex": 1,
      "explanation": "Single Responsibility原則は、1つのクラスは1つの責任のみを持つべき、つまり変更の理由が1つだけであるべきことを定義しています。これにより、クラスの変更やテストが容易になります。"
    },
    {
      "text": "Open/Closed（開放閉鎖）原則について、最も正しい説明はどれか？",
      "options": [
        { "text": "拡張には開かれ、修正には閉じられている" },
        { "text": "拡張には閉じられ、修正には開かれている" },
        { "text": "拡張と修正の両方に対して開かれている" },
        { "text": "拡張と修正の両方に対して閉じられている" }
      ],
      "correctOptionIndex": 0,
      "explanation": "Open/Closed原則は、ソフトウェアエンティティは拡張に対しては開かれ、修正に対しては閉じられているべきであることを意味します。新機能は新規ファイルで追加し、既存コードの修正は避けるべきです。"
    },
    {
      "text": "Enterprise Business Rules（エンティティ層）の特徴として正しいものはどれか？",
      "options": [
        { "text": "UIやデータベースの変更に敏感である" },
        { "text": "最も変わりやすい層であり、頻繁に修正が必要である" },
        { "text": "最も変わりにくい部分で、ビジネスの基本的なルールを表現する" },
        { "text": "フレームワークの詳細に密結合している" }
      ],
      "correctOptionIndex": 2,
      "explanation": "Enterprise Business Rules（エンティティ層）は、ビジネスの最も基本的で変わりにくいルールを表現します。UIやDBの変更から完全に独立しており、プロジェクト固有のビジネスドメイン知識を集約します。"
    },
    {
      "text": "Liskov Substitution（リスコフの置換）原則について、最も正しい説明はどれか？",
      "options": [
        { "text": "派生型は基本型と異なる動作をするべきである" },
        { "text": "派生型は基本型の代わりに使用可能であるべきである" },
        { "text": "派生型は基本型から何も継承してはならない" },
        { "text": "派生型と基本型は完全に独立していないといけない" }
      ],
      "correctOptionIndex": 1,
      "explanation": "Liskov Substitution原則は、派生型は基本型の代わりに使用可能であるべきことを定義しています。インターフェースを実装したすべてのクラスが、同じ場所で相互に置き換え可能であるべきです。"
    },
    {
      "text": "クリーンアーキテクチャにおけるテスト容易性のメリットで、最も大きいものはどれか？",
      "options": [
        { "text": "ビジネスロジックをUIやデータベースなしで独立してテストできる" },
        { "text": "全てのテストが必ず成功する" },
        { "text": "テストコードを全く書く必要がない" },
        { "text": "テスト期間が無くなる" }
      ],
      "correctOptionIndex": 0,
      "explanation": "クリーンアーキテクチャ最大のメリットは、ビジネスロジックをフレームワークやデータベースから切り離し、UIやDB呼び出しなしで独立してテストできることです。これにより、テストが高速かつシンプルになります。"
    },
    {
      "text": "従来の多層アーキテクチャ（3段階構成）と比較して、クリーンアーキテクチャの最大の違いは何か？",
      "options": [
        { "text": "レイヤー数が4層に増えたことと、名前が変わったこと" },
        { "text": "依存関係の方向性が逆転し、中心のビジネスロジックが外部に依存しないこと" },
        { "text": "データベースを使わずにメモリだけで処理するようになったこと" },
        { "text": "UIとビジネスロジックの距離が近くなったこと" }
      ],
      "correctOptionIndex": 1,
      "explanation": "最大の違いは依存関係の方向性です。従来は上位が下位に依存しますが、クリーンアーキテクチャでは外側が内側に依存し、最も重要なビジネスロジックが外部の詳細（フレームワーク、DB）に依存しないようになっています。"
    },
    {
      "text": "Interface Segregation（インターフェース分離）原則について、最も正しい説明はどれか？",
      "options": [
        { "text": "1つの大きなインターフェースを作成して、全ての機能を詰め込むべきである" },
        { "text": "大きなインターフェースより複数の特定インターフェースの方が良い" },
        { "text": "インターフェースは使わず、直接クラスに依存するべきである" },
        { "text": "インターフェースは1つだけ作成するべきである" }
      ],
      "correctOptionIndex": 1,
      "explanation": "Interface Segregation原則は、大きなインターフェースより、特定の目的に限定された複数のインターフェースを作成すべきことを定義しています。これにより、クライアントが不必要なメソッドに依存することを避けられます。"
    },
    {
      "text": "Dependency Inversion（依存性逆転）原則について、正しい説明はどれか？",
      "options": [
        { "text": "高レベルモジュールが低レベルモジュールに依存すべきである" },
        { "text": "高レベルモジュールが低レベルに依存しないようにインターフェースを使用する" },
        { "text": "依存性を逆転させることは不可能である" },
        { "text": "依存性の方向は重要ではない" }
      ],
      "correctOptionIndex": 1,
      "explanation": "Dependency Inversion原則は、高レベルモジュールが低レベルモジュールに直接依存しないようにすべきことを定義しています。両者が抽象化（インターフェース）に依存することで、依存関係を逆転させます。これはクリーンアーキテクチャの核となる原則です。"
    },
    {
      "text": "クリーンアーキテクチャを採用する場合、プロジェクトの複雑性や規模に対する考慮で正しいものはどれか？",
      "options": [
        { "text": "全てのプロジェクトに無条件に適用すべきである" },
        { "text": "小規模プロジェクト向けであり、大規模プロジェクトには不向きである" },
        { "text": "プロジェクト規模、チーム構成、ビジネス要件に基づいて導入を判断すべき" },
        { "text": "プロジェクトの规模化に応じて後から導入可能である" }
      ],
      "correctOptionIndex": 2,
      "explanation": "クリーンアーキテクチャの導入検討には、プロジェクト規模、チーム構成、ビジネス要件などを総合的に考慮する必要があります。小規模プロジェクトでは過度な抽象化になる可能性があり、段階的導入も検討すべきです。"
    },
    {
      "text": "中級問題：複数のユーザーインターフェース（Web、Mobile、CLI）から同じビジネスロジックを利用する際、クリーンアーキテクチャではどのような構造が推奨されるか？",
      "options": [
        { "text": "各UIごとに独立したビジネスロジックを実装する" },
        { "text": "Application層でビジネスロジックをUI非依存で実装し、複数のAdapterから利用する" },
        { "text": "UIコードの中にビジネスロジックを埋め込む" },
        { "text": "ビジネスロジックをコピー&ペーストして各UIに組み込む" }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャでは、Application層にUI非依存のビジネスロジック（ユースケース）を実装します。Web UI、Mobile、CLIなどの異なるAdapterがこのビジネスロジックを呼び出すため、ロジックの再利用性と保守性が向上します。"
    },
    {
      "text": "中級問題：テスト容易性を考慮した設計で、ユースケース層が外部サービス（データベース、API）に直接依存するべきでない理由は何か？",
      "options": [
        { "text": "外部サービスが遅いため、テストが遅くなるから" },
        { "text": "外部サービスのAPI仕様が変わると、ユースケースの修正が必要になるから" },
        { "text": "インターフェース（Port）を経由することで、テストで簡単にモックに置き換え可能にするため" },
        { "text": "技術的負債を減らすため" }
      ],
      "correctOptionIndex": 2,
      "explanation": "ユースケース層が具体的な実装（DB、API）に依存するのではなく、インターフェース（Port）に依存することで、テスト時に実装を簡単にモックに置き換えられます。これにより、テストが高速かつ独立して実行可能になります。"
    },
    {
      "text": "中級問題：フレームワーク変更（例：Spring → Quarkus）時に、クリーンアーキテクチャの設計がもたらすメリットは何か？",
      "options": [
        { "text": "フレームワークの変更が完全に不可能になる" },
        { "text": "Domain層とApplication層への影響が最小化され、Adapter層とFramework層のみの変更で対応可能" },
        { "text": "全ての層を新たに開発し直す必要がある" },
        { "text": "フレームワーク変更は不可能だため、最初から正しいフレームワークを選ぶしかない" }
      ],
      "correctOptionIndex": 1,
      "explanation": "クリーンアーキテクチャでは、ビジネスロジックをフレームワークから独立させています。フレームワーク変更時は、Adapter層とFramework層のみを修正すればよく、Domain層やApplication層への影響は最小化されます。これが『フレームワーク非依存』の真の価値です。"
    },
    {
      "text": "中級問題：クリーンアーキテクチャにおいて、Adapter層とFramework層を分離する理由で最も重要なものはどれか？",
      "options": [
        { "text": "ファイル数を増やすため" },
        { "text": "フォルダ構造を複雑にするため" },
        { "text": "Adapter層の実装詳細（HTTP、DB、外部API）について、Application層が知らないようにするため" },
        { "text": "特に理由はなく、慣例に従っているから" }
      ],
      "correctOptionIndex": 2,
      "explanation": "Adapter層とFramework層を分離することで、Application層はHTTP、データベース、外部APIなどの具体的な実装詳細を知りません。これにより、技術スタックの変更時の影響を最小化でき、テストも容易になります。"
    },
    {
      "text": "中級問題：ユースケース層の責務分割について、『CreateOrderUseCase』と『UpdateOrderUseCase』を分ける理由で最も正しいものはどれか？",
      "options": [
        { "text": "コードの行数を減らすことができるから" },
        { "text": "各ユースケースが単一責任を持つようになり、テストと保守が容易になるから" },
        { "text": "ファイル数を増やしたいからであり、実装的な理由はない" },
        { "text": "各メソッドは1つのユースケースのみ実行できるという制約があるから" }
      ],
      "correctOptionIndex": 1,
      "explanation": "各ユースケースを分割することで、Single Responsibility原則に従い、各クラスが単一のビジネスプロセス（注文作成 or 更新）のみに責任を持つようになります。これにより、テストがシンプルで、変更時の波及影響が最小化されます。"
    },
    {
      "text": "中級問題：クリーンアーキテクチャで『インターフェース（Port）』を定義する際、最も重要な設計原則はどれか？",
      "options": [
        { "text": "インターフェースは可能な限り大きく、多くのメソッドを含むべき" },
        { "text": "インターフェースはApplication層が実際に必要とする操作のみを定義し、実装の詳細を隠蔽すべき" },
        { "text": "インターフェースは使わず、常に具体的なクラスに依存するべき" },
        { "text": "インターフェースの数は1つだけであるべき" }
      ],
      "correctOptionIndex": 1,
      "explanation": "Port（インターフェース）は、Application層が実際に必要とする操作のみを定義すべきです。これにより、実装の詳細（DB、API仕様など）がApplication層に影響を与えず、テスト時のモック化も容易になります。"
    }
  ]
}
