{
  "id": "clean-architecture-step3",
  "title": "クリーンアーキテクチャ STEP 3: 言語実装",
  "description": "C#、TypeScript/JavaScript、Javaでのクリーンアーキテクチャの実装パターンを学ぶ",
  "difficulty": "初級～中級",
  "questions": [
    {
      "options": [
        {
          "text": "すべてのコードを1つのプロジェクトに詰め込む"
        },
        {
          "text": "各層を独立したプロジェクト（assembly）として分割し、物理的に依存関係を実行"
        },
        {
          "text": "UIとビジネスロジックのみを分割する"
        },
        {
          "text": "フォルダで分割するが、プロジェクトの分割は行わない"
        }
      ],
      "explanation": "C#では、各層を独立したプロジェクト（assembly）として分割することが推奨されます。これにより、.csprojの依存関係設定で物理的に不正な依存を防ぐことができます。例えば、Domain プロジェクトは他に依存しない、Application は Domain にのみ依存、といった制約が実行時に強制されます。",
      "id": 3,
      "question": "C#でのクリーンアーキテクチャにおいて、プロジェクトを複数に分割する場合の標準的なアプローチはどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "services.AddSingleton<IOrderRepository, SqlOrderRepository>();"
        },
        {
          "text": "services.RegisterType<IOrderRepository, SqlOrderRepository>();"
        },
        {
          "text": "DI設定を使わず、直接インスタンスを生成する"
        },
        {
          "text": "手動で依存関係の生成を管理する"
        }
      ],
      "explanation": "Microsoft.Extensions.DependencyInjectionでは、`services.AddSingleton<Interface, Implementation>()`、`AddTransient`、`AddScoped`などのメソッドで依存関係を登録します。これにより、DI コンテナが自動的に依存関係を注入します。",
      "id": 3,
      "question": "C#でのDI設定について、Microsoft.Extensions.DependencyInjectionを使用する場合、インターフェース実装クラスを登録する標準的な方法はどれか？",
      "correctAnswer": "A"
    },
    {
      "options": [
        {
          "text": "全コードを1つのindex.tsで実装する"
        },
        {
          "text": "フォルダ構造で層を分離し（src/1_domain、src/2_application等）、モジュール間の依存関係をnpmで管理する"
        },
        {
          "text": "複数のnpmパッケージに分割し、各パッケージが独立した層を表現する"
        },
        {
          "text": "クラスベースの実装を避け、関数型プログラミングのみを使用する"
        }
      ],
      "explanation": "TypeScript/JavaScriptでは、ファイルシステムがモジュール構成の基本となります。フォルダ構造で層を分離し、各フォルダ内で依存関係を管理することが実践的です。小規模プロジェクトではこれで十分であり、複数のnpm パッケージ分割は過度な複雑性になることがあります。",
      "id": 3,
      "question": "TypeScript/JavaScriptでのクリーンアーキテクチャにおいて、プロジェクト構成の分割方法として最も推奨されるのはどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "@injectable装飾子でクラスをマークし、constructor（）で依存関係を定義する"
        },
        {
          "text": "全てをnewで手動生成する"
        },
        {
          "text": "Service Locatorパターンを使って動的に取得する"
        },
        {
          "text": "グローバル変数で依存関係を共有する"
        }
      ],
      "explanation": "tsyringeでは、クラスに@injectable装飾子をマークし、constructorで依存関係を宣言します。DIコンテナが自動的に依存関係の注入を管理します。コンストラクタインジェクションにより、明示的で テストしやすい設計が実現されます。",
      "id": 3,
      "question": "TypeScript/JavaScriptでのDI設定について、tsyringeライブラリを使用する場合の基本的な設定方法はどれか？",
      "correctAnswer": "A"
    },
    {
      "options": [
        {
          "text": "Spring Boot アプリケーションの1つのプロジェクトに全ての層を含める"
        },
        {
          "text": "Mavenマルチモジュール構成で、各層を独立したモジュールとして分割する"
        },
        {
          "text": "複数のSpring Boot アプリケーションを起動して分散環境で実行する"
        },
        {
          "text": "Spring Bootを使わずに、純粋なJavaで実装する"
        }
      ],
      "explanation": "Javaではmavenマルチモジュール構成で、各層を独立したモジュール（Domain、Application、Adapter、Framework）として分割することが推奨されます。各モジュールのpom.xmlで依存関係を明示的に定義し、循環依存を防ぐことができます。",
      "id": 3,
      "question": "Javaでのクリーンアーキテクチャにおいて、Spring Bootを使用する場合のプロジェクト構成として最も推奨されるのはどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "違いはなく、どちらを使用しても同じである"
        },
        {
          "text": "@Componentは一般的なコンポーネント、@Service はビジネスロジック層の自動登録を示唆する、ただしSpring的には機能的には同じ"
        },
        {
          "text": "@Componentは自動登録されず、@Service のみ自動登録される"
        },
        {
          "text": "@Serviceは廃止されており、@Component のみ使用可能である"
        }
      ],
      "explanation": "Spring では @Component と @Service は機能的には同じです。ただし、@Service はビジネスロジック層のコンポーネントであることを意図的に示せるため、可読性の観点からビジネスロジック層には @Service を使用することが推奨されます。",
      "id": 3,
      "question": "Javaの Spring DI について、@Component と @Service の違いで最も正しい説明はどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "publicセッターを持つシンプルなPOCI（Plain Old CLR Object）として実装する"
        },
        {
          "text": "encapsulationを意識し、privateセッターやバリデーション・ロジックを含める"
        },
        {
          "text": "ORM（Entity Framework）のエンティティとドメインエンティティを完全に同じクラスにする"
        },
        {
          "text": "エンティティは持たず、全てのロジックをUseCaseに詰め込む"
        }
      ],
      "explanation": "C#でのドメインエンティティは、ビジネスルールをカプセル化するべきです。クラス内に値の妥当性チェック、状態遷移のルール、関連ロジックを含めます。publicセッターを避け、privateセッターやメソッドを介して状態変更をコントロールします。",
      "id": 3,
      "question": "エンティティ層の実装で、C##でのベストプラクティスはどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "インターフェースのみを定義し、実装クラスは持たない"
        },
        {
          "text": "readonlyプロパティを使用し、Factory Methodで生成・状態変更を管理する"
        },
        {
          "text": "すべてのプロパティをpublicで宣言し、自由に変更可能にする"
        },
        {
          "text": "プレーンなオブジェクトリテラルとしてのみ使用する"
        }
      ],
      "explanation": "TypeScriptでは、readonlyプロパティでイミュータビリティを表現し、Factory Methodパターン（例：Task.create()）で安全に生成します。状態変更はメソッド（例：complete()）を通じて行い、ビジネスルールを適用します。これにより、予期しない状態変更を防げます。",
      "id": 3,
      "question": "TypeScriptでエンティティを実装する場合のベストプラクティスはどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "ドメインエンティティにJPA注釈（@Entity、@Column等）を直接付与する"
        },
        {
          "text": "ドメインエンティティはあくまでビジネスロジックに専念し、Persistentエンティティ（JPA用）と分離する"
        },
        {
          "text": "JPAの自動生成機能を使い、データベーススキーマに完全に依存する"
        },
        {
          "text": "エンティティを使わず、DTOのみで全て実装する"
        }
      ],
      "explanation": "ドメインエンティティをJPA注釈で汚さないことが重要です。ドメインエンティティはビジネスロジックの純粋に集中し、JPA用のPersistentエンティティはAdapter層で分離して定義します。MapStruct などを使って変換することで、依存関係を保つことができます。",
      "id": 3,
      "question": "JavaでのエンティティをJPA（Hibernate）と組み合わせる場合、クリーンアーキテクチャを遵守するための重要な設計点は何か？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "実データベースを使用して、すべてのテストを実行する"
        },
        {
          "text": "Unit テストはモック化したPort を使用し、Integration テストのみ実データベースで検証する"
        },
        {
          "text": "テストを全く行わず、本番環境で検証する"
        },
        {
          "text": "Adapter層は内部実装なので、テスト対象から除外する"
        }
      ],
      "explanation": "Adapter層のテストは2段階に分かれます：Unit テストではPort をモック化してAdapter のロジックのみをテストし、Integration テストで実データベースとの連携を検証します。これにより、テスト速度（Unit テスト）と信頼性（Integration テスト）のバランスが取れます。",
      "id": 3,
      "question": "Adapter層（Repository実装）のテスト戦略で最も推奨されるのはどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "HTTP リクエストパラメータのバリデーション"
        },
        {
          "text": "リクエストからUseCaseへのデータ変換（DTO → Request）"
        },
        {
          "text": "複雑なビジネスロジックの判断や計算"
        },
        {
          "text": "UseCaseの呼び出しと、Response のHTTP ステータス変換"
        }
      ],
      "explanation": "Controller（Driving Adapter）は、HTTPプロトコルの処理（パラメータ抽出、バリデーション、ステータス決定）に専念すべきです。複雑なビジネスロジックはUseCase層やエンティティ層に委譲します。Controllerでロジック判断を行うと、ビジネスロジックが外側に漏出してしまいます。",
      "id": 3,
      "question": "Controller（Driving Adapter）の責務として、含めるべきでないものはどれか？",
      "correctAnswer": "C"
    },
    {
      "options": [
        {
          "text": "全てを1つのプロジェクトに含めて、循環参照を心配しない"
        },
        {
          "text": "各層のプロジェクトが明確な依存方向を持つようにし、循環参照を禁止する"
        },
        {
          "text": "循環参照があっても、DI設定で解決可能である"
        },
        {
          "text": "無視して、何度も相互参照する"
        }
      ],
      "explanation": "C#でプロジェクト間の循環依存を避けることは、クリーンアーキテクチャの実行を保証するための重要な設計原則です。Domain → Application → Adapter → Framework という一方向の参照のみを許可することで、アーキテクチャ違反を物理的に防ぎます。",
      "id": 3,
      "question": "中級問題：プロジェクト間の依存関係を .csproj（C#）で定義する際、循環依存を避けるための設計は何か？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "全てのコードを1ファイルに集約し、ファイルサイズを削減する"
        },
        {
          "text": "層内の主要なエクスポートをまとめて、外部からのインポートを単純化・管理する"
        },
        {
          "text": "JavaScriptトランスパイラのアーティファクトである"
        },
        {
          "text": "必須ではなく、完全にオプションである"
        }
      ],
      "explanation": "index.ts（バレルファイル）は、層内の重要なクラスやインターフェースをエクスポートし、外部からのインポートパスを単純化します。例えば、`import { CreateOrderUseCase } from '../../application'`という簡潔なインポートが可能になります。",
      "id": 3,
      "question": "中級問題：TypeScriptでのモジュール分割で、各層のindex.ts（バレルファイル）の役割は何か？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "複数の実装クラスに同じ@Service注釈を付与する"
        },
        {
          "text": "@Primary注釈でデフォルト実装を指定、@Qualifier注釈で特定の実装の注入先を指定する"
        },
        {
          "text": "手動で 1つの実装を選んでnewで生成する"
        },
        {
          "text": "複数の実装がある場合、インターフェースを使わない"
        }
      ],
      "explanation": "Javaでは、@Primary で デフォルトの実装を指定し、@Qualifier で特定の実装を指定することで、複数の実装を管理できます。例えば、複数のRepositoryがある場合、@Qualifier(\"sqlRepository\")で指定したRepository実装を注入します。",
      "id": 3,
      "question": "中級問題：Javaでの複数の同じインターフェース実装をDI コンテナで管理する場合、正しい設定方法はどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "DTOとドメインエンティティを同じクラスで実装する"
        },
        {
          "text": "AutoMapper や Mapster などのマッピングライブラリを使用して変換ロジックを明示的に管理する"
        },
        {
          "text": "手動でコンストラクト指定をコピーして、各層で実装する"
        },
        {
          "text": "DTOとエンティティの変換は不要である"
        }
      ],
      "explanation": "AutoMapper や Mapster などのマッピングライブラリは、DTO ↔ エンティティの変換ロジックを一元管理し、コードの重複を避けます。変換処理をAdapter層に集約することで、各層が互いのデータ形式を知らず、結合度が低くなります。",
      "id": 3,
      "question": "中級問題：C#でのDTO（Data Transfer Object）と ドメインエンティティの変換を実装する場合のベストプラクティスはどれか？",
      "correctAnswer": "B"
    },
    {
      "options": [
        {
          "text": "全てのRepositoryメソッド（CRUD、検索等）を1つのインターフェースに統合する"
        },
        {
          "text": "エンティティごと、または操作ごとに特化したインターフェースに分割する"
        },
        {
          "text": "Repositoryの全実装をクライアントが知っているべきである"
        },
        {
          "text": "インターフェースを使わず、具体的なクラスに直接依存する"
        }
      ],
      "explanation": "Interface Segregation 原則により、IOrderRepository はOrder の操作のみを定義し、ICustomerRepository は Customer の操作のみを定義します。さらに、読み取り（IOrderReader）と書き込み（IOrderWriter）を分割することで、各クライアントが必要な操作のみに依存します。",
      "id": 3,
      "question": "中級問題：Interface Segregation 原則に基づいて、複数の関連Repositoryportを設計する場合の推奨方法はどれか？",
      "correctAnswer": "B"
    }
  ]
}
